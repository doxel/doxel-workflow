#!/bin/bash

# Copyright (C) 2017 Alsenet SA
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License,
# or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see http://www.gnu.org/licenses/.

SENSOR_WIDTH_DB=${SENSOR_WIDTH_DB:-/usr/share/openMVG/sensor_width_camera_database.txt}
NUM_THREADS=${NUM_THREADS:-$(nproc)}

URL=${URL:-http://localhost:3001/api}
USERNAME=${USERNAME:-worker}
PASSWORD=${PASSWORD:-worker}
export DOCKER_DEFAULTS=${DOCKER_DEFAULTS:-"-v /mnt:/mnt -it --rm=true --cpus=$(nproc)"}

REQUIRED_POINTS_AFTER_OPENMVG=${REQUIRED_POINTS_AFTER_OPENMVG:-10}
REQUIRED_POINTS_AFTER_PMVS=${REQUIRED_POINTS_AFTER_PMVS=:-5000}

dependencies() {
  for cmd in node jq parallel mogrify exiftool ; do
    if ! which $cmd > /dev/null ; then
      echo Command $cmd is required !
      exit 1
    fi
  done
}

encodeURIComponent() {
  node -e "console.log(encodeURIComponent('$*'))"
}

errmsg() {
  echo "*** ERROR: $*" >&2
  log '{"error": true, "msg": "'$*'", "t": '$(date +%s)'}'
  exit 1
}

progress() {
  echo "=== $*" >&2
  log '{"msg": "'$*'", "t": '$(date +%s)'}'
}

log() {
  if [ -n "$AUTHORIZATION" -a -n "$JOB_ID" -a "$JOB_ID"!="null" ] ; then
    doxel-progress \
      --no-check-certificate \
      -a $AUTHORIZATION \
      -j $JOB_ID \
      -d $(encodeURIComponent "${*}") \
      $URL
  fi

  [ -n "$SEGMENT_DIR" ] && echo "$*" >> $SEGMENT_DIR/LOG
}

dependencies

# login

ACCESS_TOKEN=$( \
  loopback-login \
    -u $USERNAME \
    -p $PASSWORD \
    --no-check-certificate \
    $URL \
)
[ -z "$ACCESS_TOKEN" ] && errmsg login failed

AUTHORIZATION=$(jq -r .id <<< $ACCESS_TOKEN)
[ -z "$AUTHORIZATION" ] && errmsg no authorization

USER_ID=$(jq -r .userId <<< $ACCESS_TOKEN)
[ -z "$USER_ID" ] && errmsg no user id

# get job info
RESULT=$(doxel-getjob -a $AUTHORIZATION $URL)
[ -z "$RESULT" ] && errmsg no reply
if [ "$RESULT" == "{}" ] ; then
  progress No job available
  exit
fi

JOB_ID=$(jq -r .result.job.id <<< $RESULT)
[ "$JOB_ID" == "null" ] && errmsg no job id

SEGMENT_ID=$(jq -r .result.job.segmentId <<< $RESULT)
[ "$SEGMENT_ID" == "null" ] && errmsg no segment id

SEGMENT_DIR=$( \
  doxel-segment-path -s $SEGMENT_ID -a $AUTHORIZATION $URL \
  | sed -r -e 's/.*\/upload/\/mnt\/upload/' \
)

[ -z "$SEGMENT_DIR" ] && errmsg no segment dir

assert_cameraModelInDatabase() {
  progress "Looking for camera model"
  JPEG=$(find original_images -maxdepth 1 -name \*.jpeg -print -quit)
  MODEL=$(exiftool -j -model $JPEG | jq .[0].Model -r)
  if [ -n "$MODEL" ] ; then
    if grep -q -e "^$MODEL;" $SENSOR_WIDTH_DB ; then 
      progress "Found $MODEL in $SENSOR_WIDTH_DB"
    else
      errmsg "$MODEL not found in $SENSOR_WIDTH_DB"
    fi
  else
      progress "Camera model not found in EXIF"
  fi
}

sfm_init() {
  if [ -f $SEGMENT_DIR/openMVG/sfm_data.json ]
  then
    progress "Images list already exist"
  else
    progress openMVG_main_SfMInit_ImageListing
    mkdir -p $SEGMENT_DIR/openMVG
    SFMINIT_IMAGELISTING_OPTIONS=${SFMINIT_IMAGELISTING_OPTIONS:-\
    }
    progress "options: $SFMINIT_IMAGELISTING_OPTIONS"
    echo $SFMINIT_IMAGELISTING_OPTIONS > $SEGMENT_DIR/openMVG/SFMINIT_IMAGELISTING_OPTIONS
    openMVG_main_SfMInit_ImageListing \
      -i $SEGMENT_DIR/original_images \
      -o $SEGMENT_DIR/openMVG \
      -d $SENSOR_WIDTH_DB \
      $SFMINIT_IMAGELISTING_OPTIONS

    EXIT_CODE=$?
    if [ $EXIT_CODE -ne 0 ] ; then
      [ -f $SEGMENT_DIR/openMVG/sfm_data.json ] && rm $SEGMENT_DIR/openMVG/sfm_data.json
      errmsg "openMVG_main_SfMInit_ImageListing exited with status $EXIT_CODE"
    fi
  fi
}

compute_features() {
  if [ -n "$(find $SEGMENT_DIR/openMVG/matches/ -maxdepth 1 -iname \*.feat -print -quit)" ]
  then
    progress Features already exist
  else
    progress openMVG_main_ComputeFeatures
    COMPUTEFEATURES_OPTIONS=${COMPUTEFEATURES_OPTIONS:-\
      -m SIFT \
    }
    progress "options: $COMPUTEFEATURES_OPTIONS"
    echo $COMPUTEFEATURES_OPTIONS > $SEGMENT_DIR/openMVG/COMPUTEFEATURES_OPTIONS
    openMVG_main_ComputeFeatures \
      -o $SEGMENT_DIR/openMVG/matches/ \
      -i $SEGMENT_DIR/openMVG/sfm_data.json \
      -n $NUM_THREADS \
      $COMPUTEFEATURES_OPTIONS

    EXIT_CODE=$?
    if [ $EXIT_CODE -ne 0 ] ; then
       find $SEGMENT_DIR/openMVG/matches/ -maxdepth 1 -iname \*.feat -or -iname \*.desc -exec rm '{}' \;
      errmsg openMVG_main_ComputeFeatures exited with status $EXIT_CODE
    fi
  fi
}

compute_matches() {
  if [ -n "$(find $SEGMENT_DIR/openMVG/matches/ -maxdepth 1 -name matches.putative.\* -print -quit)" ]
  then
    progress Matches already done
  else
    progress openMVG_main_ComputeMatches
    COMPUTEMATCHES_OPTIONS=${COMPUTEMATCHES_OPTIONS:-\
      -g e \
      -v 12 \
    }
    progress "options: $COMPUTEMATCHES_OPTIONS"
    echo $COMPUTEMATCHES_OPTIONS > $SEGMENT_DIR/openMVG/COMPUTEMATCHES_OPTIONS
    openMVG_main_ComputeMatches \
      -i $SEGMENT_DIR/openMVG/sfm_data.json \
      -o $SEGMENT_DIR/openMVG/matches \
      $COMPUTEMATCHES_OPTIONS

    EXIT_CODE=$?
    if [ $EXIT_CODE -ne 0 ] ; then
      find $SEGMENT_DIR/openMVG/matches/ -maxdepth 1 -iname matches.putative.\* -exec rm '{}' \;
      errmsg "openMVG_main_ComputeMatches exited with status $EXIT_CODE"
    fi
  fi
}

global_sfm() {
  if [ -f $SEGMENT_DIR/openMVG/SfMReconstruction_Report.html ]
  then
    progress "GlobalSfM already done"
  else
    progress openMVG_main_GlobalSfM
    GLOBALSFM_OPTIONS=${GLOBALSFM_OPTIONS:-\
    }
    progress "options: $GLOBALSFM_OPTIONS"
    echo $GLOBALSFM_OPTIONS > $SEGMENT_DIR/openMVG/GLOBALSFM_OPTIONS
    openMVG_main_GlobalSfM \
      -i $SEGMENT_DIR/openMVG/sfm_data.json \
      -m $SEGMENT_DIR/openMVG/matches \
      -o $SEGMENT_DIR/openMVG/ \
      $GLOBALSFM_OPTIONS

    EXIT_CODE=$?
    if [ $EXIT_CODE -ne 0 ] ; then
       find $SEGMENT_DIR/openMVG/SfMReconstruction_Report.html -maxdepth 1 -exec rm '{}' \;
      errmsg "openMVG_main_GlobalSfM exited with status $EXIT_CODE"
    fi
  fi
}

compute_structure_from_known_poses() {
  if [ -f $SEGMENT_DIR/openMVG/robust.ply ]
  then
    progress "Compute Structure From Known Poses already done"
  else
    progress openMVG_main_ComputeStructureFromKnownPoses
    COMPUTESTRUCTUREFROMKNOWNPOSES_OPTIONS=${COMPUTESTRUCTUREFROMKNOWNPOSES_OPTIONS:-\
    }
    progress "options: $COMPUTESTRUCTUREFROMKNOWNPOSES_OPTIONS"
    echo $COMPUTESTRUCTUREFROMKNOWNPOSES_OPTIONS > $SEGMENT_DIR/openMVG/COMPUTESTRUCTUREFROMKNOWNPOSES_OPTIONS
    openMVG_main_ComputeStructureFromKnownPoses \
      -i $SEGMENT_DIR/openMVG/sfm_data.bin \
      -m $SEGMENT_DIR/openMVG/matches \
      -o $SEGMENT_DIR/openMVG/robust.json \
      $COMPUTESTRUCTUREFROMKNOWNPOSES_OPTIONS

    EXIT_CODE=$?
    if [ $EXIT_CODE -ne 0 ] ; then
       [ -f $SEGMENT_DIR/openMVG/robust.ply ] && rm $SEGMENT_DIR/openMVG/robust.ply
      errmsg "openMVG_main_ComputeStructureFromKnownPoses exited with status $EXIT_CODE"
    fi
  fi
}

openmvg2pmvs() {
  if [ -n "$(find $SEGMENT_DIR/PMVS/ -maxdepth 1 -name pmvs_options.txt -print -quit)" ]
  then
    progress "PMVS directory already exist"
  else
    progress openMVG_main_openMVG2PMVS
    OPENMVG2PMVS_OPTIONS=${OPENMVG2PMVS_OPTIONS:-\
    }
    progress "options: $OPENMVG2PMVS_OPTIONS"
    echo $OPENMVG2PMVS_OPTIONS > $SEGMENT_DIR/openMVG/OPENMVG2PMVS_OPTIONS
    openMVG_main_openMVG2PMVS \
      -i $SEGMENT_DIR/openMVG/robust.json \
      -o $SEGMENT_DIR \
      $OPENMVG2PMVS_OPTIONS

    EXIT_CODE=$?
    if [ $EXIT_CODE -ne 0 ] ; then
       [ -d $SEGMENT_DIR/PMVS ] && rm -r $SEGMENT_DIR/PMVS
      errmsg "openMVG_main_openMVG2PMVS exited with status $EXIT_CODE"
    fi
  fi
}

cmvspmvs() {
  if [ -n "$(find $SEGMENT_DIR/PMVS/models/ -type f -print -quit)" ]
  then
    progress "PMVS models directory already exist"
  else
    progress "Running CMVS/PMVS"
    cmvs $(pwd)/PMVS/ 80 $NUM_THREADS \
    && genOption $(pwd)/PMVS/ \
    && sed -i "s# pmvs# $(pwd)/PMVS#g" PMVS/pmvs.sh \
    && bash PMVS/pmvs.sh

    EXIT_CODE=$?
    if [ $EXIT_CODE -ne 0 ] ; then
     #  [ -d $SEGMENT_DIR/PMVS/models ] && rm -r $SEGMENT_DIR/PMVS/models
      errmsg "CMVS/PMVS exited with status $EXIT_CODE"
    fi
  fi
}

assert_hasPoints() {
  TOTAL=0
  while [ -f $1 ] ; do
    f=$1
    shift
    VERTEX_COUNT=$(grep element.vertex $f | awk '{print $NF}')
    if [ -z "$VERTEX_COUNT" ] ; then
      errmsg "Cannot read \"element vertex\" property from $f"
    fi
    TOTAL=$((TOTAL+VERTEX_COUNT))
  done
  if [ $TOTAL -lt $1 ] ; then
    completed $(date +%s) "Discarded: $TOTAL points"
    exit
  fi
}

viewer() {
  if [ -d $SEGMENT_DIR/potree ]
  then
    progress "Potree directory already exist"
  else
    progress "Running viewer.sh"
    viewer.sh

    EXIT_CODE=$?
    if [ $EXIT_CODE -ne 0 ] ; then
       [ -d $SEGMENT_DIR/potree ] && rm -r $SEGMENT_DIR/potree
      errmsg "viewer.sh exited with status $EXIT_CODE" >&2
    fi
    touch $SEGMENT_DIR/processed

  fi
}

inject() {
  progress Injecting pointcloud into database
  doxel-segment-inject-pointcloud \
    --no-check-certificate \
    -a $AUTHORIZATION \
    -s $SEGMENT_ID \
    $URL

  EXIT_CODE=$?
  if [ $EXIT_CODE -ne 0 ] ; then
    errmsg "doxel-segment-pointcloud-inject exited with status $EXIT_CODE" >&2
  fi

}

completed(){
  progress "Set job as completed"
  log '{"msg": "completed", "t": '$1', "completion_status": "'$2'"}' || exit
}

process_segment() {
  set -x
  SEGMENT_DIR=$1
  cd $SEGMENT_DIR || errmsg "no such directory: $SEGMENT_DIR"
  progress "$SEGMENT_DIR"

  assert_cameraModelInDatabase
  sfm_init
  compute_features
  compute_matches
  global_sfm
  compute_structure_from_known_poses
  assert_hasPoints openMVG/robust.ply $REQUIRED_POINTS_AFTER_OPENMVG
  openmvg2pmvs
  cmvspmvs
  assert_hasPoints PMVS/models/option-????.ply $REQUIRED_POINTS_AFTER_PMVS
  viewer
  inject
  completed $(date -r $SEGMENT_DIR/processed +%s) ok
}

process_segment $SEGMENT_DIR
